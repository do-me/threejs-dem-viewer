<!DOCTYPE html>
<html lang="en">
<head>
    <title>Enhanced 3D Heightmap with Dynamic Slicing</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1">
    <style>
        body {
            font-family: monospace;
            background-color: #111;
            color: #fff;
            margin: 0;
            overflow: hidden;
        }
        #upload-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px 15px;
            border-radius: 5px;
            border: 1px solid #555;
        }
        input[type="file"] {
            display: none;
        }
        label.file-upload-button {
            cursor: pointer;
            padding: 8px 12px;
            background-color: #333;
            border: 1px solid #777;
            border-radius: 3px;
            font-size: 14px;
        }
        label.file-upload-button:hover {
            background-color: #555;
        }
    </style>
</head>

<body>
    <div id="upload-container">
        <label for="file-input" class="file-upload-button">Upload Heightmap Image (PNG, JPG)</label>
        <input type="file" id="file-input" accept="image/png, image/jpeg, image/tiff">
    </div>

    <!-- Import maps for three.js modules -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "dat.gui": "https://unpkg.com/dat.gui@0.7.9/build/dat.gui.module.js"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GUI } from 'dat.gui';

        // --- Scene Globals ---
        let scene, camera, renderer, controls;
        let planeMesh;
        let directionalLight, hemisphereLight;
        let dLightHelper; 
        
        // Slicing planes
        const slicePlanes = [
            new THREE.Plane(new THREE.Vector3(1, 0, 0), 100),
            new THREE.Plane(new THREE.Vector3(-1, 0, 0), 100),
            new THREE.Plane(new THREE.Vector3(0, 0, 1), 100),
            new THREE.Plane(new THREE.Vector3(0, 0, -1), 100)
        ];
        
        const settings = {
            // Model
            extrusion: 45,
            lod: 256,
            color: '#c7c7c7',
            wireframe: false,
            // Hemisphere Light
            skyColor: '#cdeeff',
            groundColor: '#4d4d4d',
            hemisphereIntensity: 0.6,
            // Directional Light (Sun)
            dLightColor: '#ffffff',
            dLightIntensity: 1.2,
            dLightX: 120,
            dLightY: 150,
            dLightZ: 80,
            showDLightHelper: false,
            // Slicing
            sliceX: 100,
            sliceNegativeX: 100,
            sliceZ: 100,
            sliceNegativeZ: 100,
            enableSlicing: false
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 90, 140);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.clippingPlanes = slicePlanes;
            document.body.appendChild(renderer.domElement);

            setupLights();

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;

            window.addEventListener('resize', onWindowResize, false);
            document.getElementById('file-input').addEventListener('change', handleFileSelect, false);
            
            setupGUI();
            
            animate();
        }

        function setupLights() {
            hemisphereLight = new THREE.HemisphereLight(settings.skyColor, settings.groundColor, settings.hemisphereIntensity);
            scene.add(hemisphereLight);

            directionalLight = new THREE.DirectionalLight(settings.dLightColor, settings.dLightIntensity);
            directionalLight.position.set(settings.dLightX, settings.dLightY, settings.dLightZ);
            directionalLight.castShadow = true;

            const shadowCamSize = 200; 
            directionalLight.shadow.camera.left = -shadowCamSize;
            directionalLight.shadow.camera.right = shadowCamSize;
            directionalLight.shadow.camera.top = shadowCamSize;
            directionalLight.shadow.camera.bottom = -shadowCamSize;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 500;

            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            dLightHelper = new THREE.DirectionalLightHelper(directionalLight, 10);
            dLightHelper.visible = settings.showDLightHelper;
            scene.add(dLightHelper);
        }

        function createTerrain(texture) {
            if (planeMesh) {
                scene.remove(planeMesh);
                planeMesh.geometry.dispose();
                planeMesh.material.dispose();
            }

            const geometry = new THREE.PlaneGeometry(200, 200, settings.lod, settings.lod);
            
            const material = new THREE.MeshStandardMaterial({
                color: settings.color,
                metalness: 0.2,
                roughness: 0.8,
                wireframe: settings.wireframe,
                displacementMap: texture,
                displacementScale: settings.extrusion,
                clippingPlanes: slicePlanes,
                clipShadows: true
            });

            planeMesh = new THREE.Mesh(geometry, material);
            planeMesh.rotation.x = -Math.PI / 2;
            planeMesh.receiveShadow = true;
            planeMesh.castShadow = true;
            scene.add(planeMesh);
        }

        function setupGUI() {
            const gui = new GUI();

            const modelFolder = gui.addFolder('Terrain Model');
            modelFolder.add(settings, 'extrusion', 0, 100, 1).name('Extrusion').onChange(v => {
                if (planeMesh) planeMesh.material.displacementScale = v;
            });
            modelFolder.add(settings, 'lod', 32, 512, 32).name('Level of Detail').onFinishChange(() => {
                 if (planeMesh) createTerrain(planeMesh.material.displacementMap);
            });
            modelFolder.addColor(settings, 'color').name('Color').onChange(v => {
                if(planeMesh) planeMesh.material.color.set(v);
            });
            modelFolder.add(settings, 'wireframe').name('Wireframe').onChange(v => {
                if (planeMesh) planeMesh.material.wireframe = v;
            });
            modelFolder.open();

            const lightFolder = gui.addFolder('Lighting');
            const hemiFolder = lightFolder.addFolder('Ambient');
            hemiFolder.addColor(settings, 'skyColor').name('Sky Color').onChange(v => hemisphereLight.color.set(v));
            hemiFolder.addColor(settings, 'groundColor').name('Ground Color').onChange(v => hemisphereLight.groundColor.set(v));
            hemiFolder.add(settings, 'hemisphereIntensity', 0, 2, 0.1).name('Intensity').onChange(v => hemisphereLight.intensity = v);

            const sunFolder = lightFolder.addFolder('Sun Light');
            sunFolder.addColor(settings, 'dLightColor').name('Color').onChange(v => directionalLight.color.set(v));
            sunFolder.add(settings, 'dLightIntensity', 0, 5, 0.1).name('Intensity').onChange(v => directionalLight.intensity = v);
            sunFolder.add(settings, 'dLightX', -200, 200, 5).name('Position X').onChange(v => directionalLight.position.x = v);
            sunFolder.add(settings, 'dLightY', 0, 400, 5).name('Position Y').onChange(v => directionalLight.position.y = v);
            sunFolder.add(settings, 'dLightZ', -200, 200, 5).name('Position Z').onChange(v => directionalLight.position.z = v);
            sunFolder.add(settings, 'showDLightHelper').name('Show Helper').onChange(v => dLightHelper.visible = v);
            
            lightFolder.open();

            const slicingFolder = gui.addFolder('Slicing');
            slicingFolder.add(settings, 'enableSlicing').name('Enable Slicing').onChange(v => {
                renderer.localClippingEnabled = v;
            });
            slicingFolder.add(settings, 'sliceX', 0, 100, 1).name('Slice X+').onChange(v => {
                slicePlanes[0].constant = v;
            });
            slicingFolder.add(settings, 'sliceNegativeX', 0, 100, 1).name('Slice X-').onChange(v => {
                slicePlanes[1].constant = v;
            });
            slicingFolder.add(settings, 'sliceZ', 0, 100, 1).name('Slice Z+').onChange(v => {
                slicePlanes[2].constant = v;
            });
            slicingFolder.add(settings, 'sliceNegativeZ', 0, 100, 1).name('Slice Z-').onChange(v => {
                slicePlanes[3].constant = v;
            });
            slicingFolder.open();
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const textureLoader = new THREE.TextureLoader();
                    textureLoader.load(e.target.result, function(texture) {
                        createTerrain(texture);
                        document.getElementById('upload-container').style.display = 'none';
                    });
                };
                reader.readAsDataURL(file);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            
            if(dLightHelper.visible) dLightHelper.update();
            
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>